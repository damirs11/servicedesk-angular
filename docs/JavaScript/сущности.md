### Введение
Сущности - классы, наследующиеся от SD.Entity.
Этот класс добавляет кэширование объектов по ID. 
Это необходимо, чтобы 2 разных ообъекта с одним ID (по сути, одна и та же сущнсоть)
при обновлении в разных местах кода обновились одновременно.

*Пример ситуации:* у нас есть отображаемая персона в хидере, и мы открыли страницу редактирования этой персоны.
Как только мы поменяем ее - она также изменится и в хидере. От нас для этого не требуется никаких дополнительных действий.

### Правила использования:
Есть несколько способов создать сущность.
* через функцию-конструктор
  * Если передать ID - на сущность будет действовать кэширование
  * Если не передать ID, считается, что мы создаем сущность, 
которой нет в БД и после ее закомиттим на сервер. Кэш не работает на такие сущности
* через статичный метод .parse(data). Он принимает json объект с данными или ID. 
  * При передаче ID срабатывает как конструктор с id
  * Если передать данные, вытащит оттуда ID, а остальные данные спрасит в объект (см. парсинг данных)
  
Есть метод $update(data) который считается приватным. Кроме как внутри класса его нигде не использовать.
$update() - работает с парсерами, которые добавляет @Parse(). 
  
#### Парсинг данных
Для того, чтобы json данные распарсились при .parse() необходимо в класс
добавить поля, над которыми повесить декоратор @Parse()

@Parse принимает в любом порядке:
* [parser] - Функцию, которая после обработки, должна вернуть значение. Оно попадет в поле
* [name] - Строку. Название поля в json данных.

**Примеры использования**

Данный парсер будет заносить из jsonData.firstName в firstName без каких-либо условий парсинга. Что пришло, то и занесли.
```JavaScript
import {Parse} from "../../client/src/main/js/api/entity/decorator/parse.decorator";


class Person{
    
    @Parse() firstName
}
````

Чуть сложнее: в юзере нам приходит объектом персона jsonData.person, которую мы должны превратить в SD.Person и занести в owner.

```JavaScript
import {Parse} from "../../client/src/main/js/api/entity/decorator/parse.decorator";


class User{
    
    @Parse("person",data => SD.Person.parse(data)) owner
}
````

### Запросы к серверу на получение
Если есть необходимость, чтобы сущность можно было найти по ID,
Добавляем ей метод async load(). Он должен изменить текущую персону.

Пример такого использования:
```JavaScript
import {Parse} from "../../client/src/main/js/api/entity/decorator/parse.decorator";

class Person{
    // some code
    
    async load(){
        const data = await $connector.get(`rest/entity/Person/${this.id}`);
        return this.$update(data);
    }
}
````
И само использование
```JavaScript
async function controllerMethod(){
    const id = resolveId();
    const person = await new SD.Person(id).load();
}
````
#### **Примечания:**
* .load() асинхронный. Если использовать без await - мы получим промис. А если просто занести в переменную SD.Person, получим пустую персону с одним лишь id
* $connector описан в "вызов_ajax-запросов.md"

Для поиска персон можно добавить **static async list(filter)**.
Он должен вернуть промис, который резолвнет список сущностей.


## Запросы к серверу на создание и сохранение
Пока это не реализовано. Необходимо будет в классе также проставлять другой декоратор над полями.
Благодаря этому декоратору будут собираться объекты в json, который отправится на сохранение/изменение.

Будут асинхронные .save() и .create(). Скорее всего они будут внутри главного класса - Entity, и заниматься их редактированием не придется.


### Некоторые возможности
* Объект при необходимости можно "обнулить". Если мы создали персону и вносим в объект изменения - они не влияют на кэш. Метод reset откатывает объект до кэшированной версии:
```JavaScript
    const person = new Person(1234);
    assert(person.firstName === "Петр");
    person.firstName = "Иван"; // Внесли другое имя
    assert(person.firstName === "Иван");
    person.reset(); // Сбрасываем объект до кэшированного
    assert(person.firstName === "Петр");
```